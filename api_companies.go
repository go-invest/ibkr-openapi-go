/*
 * ibkr
 *
 * ibkr API
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// CompaniesApiService CompaniesApi service
type CompaniesApiService service

/*
ListPortfolio Method for ListPortfolio
List properties of portfolio
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return Portfolio
*/
func (a *CompaniesApiService) ListPortfolio(ctx _context.Context) (Portfolio, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Portfolio
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/portfolio"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ListQuotesOpts Optional parameters for the method 'ListQuotes'
type ListQuotesOpts struct {
    Routing optional.String
    Exchange optional.String
    Currency optional.String
    DurationSize optional.String
    DurationUnit optional.String
    BarSize optional.String
    BarUnit optional.String
}

/*
ListQuotes Method for ListQuotes
List properties of quotes
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ticker string ticker (name or id) of the quotes
 * @param optional nil or *ListQuotesOpts - Optional Parameters:
 * @param "Routing" (optional.String) -  string routing (name or id) of the quotes
 * @param "Exchange" (optional.String) -  string exchange (name or id) of the quotes
 * @param "Currency" (optional.String) -  string currency (name or id) of the quotes
 * @param "DurationSize" (optional.String) -  string duration_size (name or id) of the quotes
 * @param "DurationUnit" (optional.String) -  string duration_unit (name or id) of the quotes
 * @param "BarSize" (optional.String) -  string bar_size (name or id) of the quotes
 * @param "BarUnit" (optional.String) -  string bar_unit (name or id) of the quotes
@return Quotes
*/
func (a *CompaniesApiService) ListQuotes(ctx _context.Context, ticker string, localVarOptionals *ListQuotesOpts) (Quotes, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Quotes
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/quotes/{ticker}"
	localVarPath = strings.Replace(localVarPath, "{"+"ticker"+"}", _neturl.QueryEscape(parameterToString(ticker, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Routing.IsSet() {
		localVarQueryParams.Add("routing", parameterToString(localVarOptionals.Routing.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Exchange.IsSet() {
		localVarQueryParams.Add("exchange", parameterToString(localVarOptionals.Exchange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Currency.IsSet() {
		localVarQueryParams.Add("currency", parameterToString(localVarOptionals.Currency.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DurationSize.IsSet() {
		localVarQueryParams.Add("duration_size", parameterToString(localVarOptionals.DurationSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DurationUnit.IsSet() {
		localVarQueryParams.Add("duration_unit", parameterToString(localVarOptionals.DurationUnit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BarSize.IsSet() {
		localVarQueryParams.Add("bar_size", parameterToString(localVarOptionals.BarSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BarUnit.IsSet() {
		localVarQueryParams.Add("bar_unit", parameterToString(localVarOptionals.BarUnit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ListScanOpts Optional parameters for the method 'ListScan'
type ListScanOpts struct {
    Type_ optional.String
    LocationCode optional.String
    ScanCode optional.String
    AboveVolume optional.String
    Limit optional.String
}

/*
ListScan Method for ListScan
List properties of scan
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ListScanOpts - Optional Parameters:
 * @param "Type_" (optional.String) -  string type (name or id) of the scan
 * @param "LocationCode" (optional.String) -  string locationCode (name or id) of the scan
 * @param "ScanCode" (optional.String) -  string scanCode (name or id) of the scan
 * @param "AboveVolume" (optional.String) -  string aboveVolume (name or id) of the scan
 * @param "Limit" (optional.String) -  string limit (name or id) of the scan
@return Scan
*/
func (a *CompaniesApiService) ListScan(ctx _context.Context, localVarOptionals *ListScanOpts) (Scan, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Scan
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/scan"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationCode.IsSet() {
		localVarQueryParams.Add("locationCode", parameterToString(localVarOptionals.LocationCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScanCode.IsSet() {
		localVarQueryParams.Add("scanCode", parameterToString(localVarOptionals.ScanCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AboveVolume.IsSet() {
		localVarQueryParams.Add("aboveVolume", parameterToString(localVarOptionals.AboveVolume.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
